# Phase 2 — Cloudflare Infrastructure

Standing up the backend for version check at `forest.dliv.gg`.

Prerequisite: Phase 1 code changes are merged and the client-side version check is in place (gracefully failing until this phase completes).

**Worker code lives in `worker/` subdirectory** of the main `dliv/workforest` repo. No separate repo needed — it's just a TypeScript/Wrangler project alongside the Rust CLI.

## Key Decisions

- **Shared types via ts-rs:** The `VersionResponse` struct in Rust derives `TS` (from the `ts-rs` crate) to auto-generate a TypeScript type. The worker imports this generated type — one source of truth for the wire format.
- **`just` for all tasks:** All Cloudflare operations (deploy, db migrate, secrets) are `just` recipes. No bare `wrangler` commands to remember.
- **Age-encrypted secrets for gitops:** Cloudflare credentials (API token, account ID, KV namespace ID) are age-encrypted and checked into the repo. Decrypted at deploy time. Secrets live in `worker/secrets/` — the `.age` files are committed, plaintext is gitignored.
- **Privacy-first logging:** Store city/country from Cloudflare's `request.cf` object instead of IP addresses.

## 0. Shared Types with ts-rs

Add `ts-rs` as a dev dependency in `Cargo.toml`:

```toml
[dev-dependencies]
ts-rs = "10"
```

Derive `TS` on the response struct in `src/version_check.rs`:

```rust
#[cfg_attr(test, derive(ts_rs::TS))]
#[cfg_attr(test, ts(export, export_to = "worker/src/generated/"))]
#[derive(Deserialize)]
struct VersionResponse {
    version: String,
}
```

The `#[cfg_attr(test, ...)]` means `TS` is only derived in test builds — no runtime cost. Running `cargo test` generates `worker/src/generated/VersionResponse.ts`:

```typescript
// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.
export type VersionResponse = { version: string };
```

Add a `just` recipe to regenerate types:

```just
generate-types:
    cargo test export_bindings -- --ignored
```

The worker imports from the generated file:

```typescript
import type { VersionResponse } from "./generated/VersionResponse";
```

## 1. DNS: `forest.dliv.gg` Subdomain

In Cloudflare dashboard for `dliv.gg`:

- **Do not** add a DNS record manually for `forest` — Cloudflare Workers Custom Domains handle this automatically
- Instead, use Workers > your worker > Settings > Domains & Routes > Add Custom Domain: `forest.dliv.gg`
- Cloudflare creates the necessary DNS record and SSL cert automatically
- Existing records for `dliv.gg`, `www`, etc. are untouched

## 2. Create D1 Database

```bash
just worker-db-create
```

### Schema (`worker/schema.sql`)

```sql
CREATE TABLE events (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  city TEXT,
  country TEXT,
  version TEXT NOT NULL,
  timestamp TEXT NOT NULL
);

CREATE INDEX idx_events_timestamp ON events(timestamp);
```

Apply:

```bash
just worker-db-migrate
```

## 3. Create KV Namespace

```bash
just worker-kv-create
```

Note the namespace ID from the output — add it to `worker/wrangler.toml` and encrypt it for CI.

Seed the initial version:

```bash
just worker-kv-seed
```

## 4. Secrets Management

### Age encryption for gitops

Secrets are age-encrypted and committed. Only the age identity (private key) needs to stay out of the repo.

```
worker/secrets/
  cf-credentials.env.age    ← committed (encrypted)
  cf-credentials.env        ← gitignored (plaintext, decrypted at deploy time)
  age-identity.txt           ← gitignored (private key, never committed)
```

**`worker/secrets/cf-credentials.env`** (plaintext, gitignored):

```bash
CF_API_TOKEN=<cloudflare api token>
CF_ACCOUNT_ID=<cloudflare account id>
CF_KV_NAMESPACE_ID=<kv namespace id>
```

**Encrypt:**

```bash
just worker-secrets-encrypt
```

**Decrypt** (requires age identity):

```bash
just worker-secrets-decrypt
```

The GitHub Actions release workflow uses the same encrypted file — the age identity is stored as a single GitHub secret (`AGE_SECRET_KEY`), and the workflow decrypts at runtime.

## 5. Worker Code

Located at `worker/` in the main repo:

```
workforest/
  src/                          ← Rust CLI
  worker/                       ← Cloudflare Worker
    src/
      index.ts
      generated/
        VersionResponse.ts      ← auto-generated by ts-rs
    secrets/
      cf-credentials.env.age   ← committed (encrypted)
    wrangler.toml
    package.json
    schema.sql
```

### `worker/src/index.ts`

```typescript
import type { VersionResponse } from "./generated/VersionResponse";

interface Env {
  DB: D1Database;
  KV: KVNamespace;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);

    if (url.pathname !== "/api/latest") {
      return new Response("Not found", { status: 404 });
    }

    if (request.method !== "GET") {
      return new Response("Method not allowed", { status: 405 });
    }

    const version = url.searchParams.get("v") || "unknown";
    const cf = (request as any).cf || {};
    const city = cf.city || null;
    const country = cf.country || null;
    const timestamp = new Date().toISOString();

    // Log to D1 (best-effort, don't fail the response)
    try {
      await env.DB.prepare(
        "INSERT INTO events (city, country, version, timestamp) VALUES (?, ?, ?, ?)",
      )
        .bind(city, country, version, timestamp)
        .run();
    } catch (e) {
      console.error("D1 write failed:", e);
    }

    // Return latest version from KV
    const latest = await env.KV.get("latest_version");
    const response: VersionResponse = {
      version: latest || "0.2.3",
    };
    return Response.json(response);
  },
};
```

### `worker/wrangler.toml`

```toml
name = "git-forest-api"
main = "src/index.ts"
compatibility_date = "2026-02-16"

[[d1_databases]]
binding = "DB"
database_name = "git-forest-version-check"
database_id = "<from step 2>"

[[kv_namespaces]]
binding = "KV"
id = "<from step 3>"
```

## 6. Just Recipes

Add to the project `justfile`:

```just
# --- Worker (Cloudflare) ---

worker-deploy:
    cd worker && wrangler deploy

worker-db-create:
    wrangler d1 create git-forest-version-check

worker-db-migrate:
    wrangler d1 execute git-forest-version-check --file=worker/schema.sql

worker-kv-create:
    wrangler kv namespace create GIT_FOREST_KV

worker-kv-seed:
    @echo "Set KV namespace ID in wrangler.toml first"
    cd worker && wrangler kv key put --binding=KV latest_version "0.2.3"

worker-secrets-encrypt:
    age -R worker/secrets/age-recipients.txt -o worker/secrets/cf-credentials.env.age worker/secrets/cf-credentials.env

worker-secrets-decrypt:
    age -d -i worker/secrets/age-identity.txt -o worker/secrets/cf-credentials.env worker/secrets/cf-credentials.env.age

worker-logs:
    cd worker && wrangler tail

worker-query sql:
    wrangler d1 execute git-forest-version-check --command "{{sql}}"
```

## 7. Wire Release Workflow to Update KV

Add an `update-version` job to `.github/workflows/release.yml`:

```yaml
update-version:
  needs: build
  runs-on: ubuntu-latest
  steps:
    - uses: actions/checkout@v4

    - name: Decrypt secrets
      env:
        AGE_SECRET_KEY: ${{ secrets.AGE_SECRET_KEY }}
      run: |
        echo "$AGE_SECRET_KEY" > /tmp/age-key.txt
        age -d -i /tmp/age-key.txt -o worker/secrets/cf-credentials.env worker/secrets/cf-credentials.env.age
        rm /tmp/age-key.txt

    - name: Update latest version in Cloudflare KV
      run: |
        set -a && source worker/secrets/cf-credentials.env && set +a
        VERSION="${GITHUB_REF_NAME#v}"
        curl -X PUT \
          "https://api.cloudflare.com/client/v4/accounts/$CF_ACCOUNT_ID/storage/kv/namespaces/$CF_KV_NAMESPACE_ID/values/latest_version" \
          -H "Authorization: Bearer $CF_API_TOKEN" \
          -H "Content-Type: text/plain" \
          --data "$VERSION"
```

### GitHub Secret

Only one secret needed:

- `AGE_SECRET_KEY` — the age identity (private key) contents

All other credentials are in the encrypted file in the repo.

## 8. Querying Usage Data

```bash
# Active users by location (last 7 days)
just worker-query "SELECT city, country, version, COUNT(*) as hits, MAX(timestamp) as last_seen FROM events WHERE timestamp > datetime('now', '-7 days') GROUP BY city, country, version ORDER BY hits DESC"

# Version adoption
just worker-query "SELECT version, COUNT(*) as checks FROM events WHERE timestamp > datetime('now', '-30 days') GROUP BY version"

# Geographic distribution
just worker-query "SELECT country, COUNT(*) as checks FROM events WHERE timestamp > datetime('now', '-30 days') GROUP BY country ORDER BY checks DESC"
```

## 9. End-to-End Test

After deploying:

1. `curl https://forest.dliv.gg/api/latest?v=0.2.3` — should return `{"version":"0.2.3"}`
2. `git forest version --check` — should show current version and latest (matching)
3. Manually bump KV:
   ```bash
   just worker-query "-- not a query, use wrangler directly"
   cd worker && wrangler kv key put --binding=KV latest_version "99.0.0"
   ```
4. Wait for daily cache to expire (or delete state.toml), run any command — should see update notice on stderr
5. Reset KV back to actual version

## 10. Future Improvements (Not in Scope)

- Automate Homebrew formula updates in the release workflow (push SHA256 updates to `dliv/homebrew-tools`)
- Add Linux builds to the release matrix
- Retention policy for D1 events (delete old rows periodically)
- Worker deploy via CI (currently manual `just worker-deploy`)
